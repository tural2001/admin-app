{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.fmin = global.fmin || {});\n})(this, function (exports) {\n  'use strict';\n\n  /** finds the zeros of a function, given two starting points (which must\n   * have opposite signs */\n  function bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n      tolerance = parameters.tolerance || 1e-10,\n      fA = f(a),\n      fB = f(b),\n      delta = b - a;\n    if (fA * fB > 0) {\n      throw \"Initial bisect points must have opposite signs\";\n    }\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n    for (var i = 0; i < maxIterations; ++i) {\n      delta /= 2;\n      var mid = a + delta,\n        fMid = f(mid);\n      if (fMid * fA >= 0) {\n        a = mid;\n      }\n      if (Math.abs(delta) < tolerance || fMid === 0) {\n        return mid;\n      }\n    }\n    return a + delta;\n  }\n\n  // need some basic operations on vectors, rather than adding a dependency,\n  // just define here\n  function zeros(x) {\n    var r = new Array(x);\n    for (var i = 0; i < x; ++i) {\n      r[i] = 0;\n    }\n    return r;\n  }\n  function zerosM(x, y) {\n    return zeros(x).map(function () {\n      return zeros(y);\n    });\n  }\n  function dot(a, b) {\n    var ret = 0;\n    for (var i = 0; i < a.length; ++i) {\n      ret += a[i] * b[i];\n    }\n    return ret;\n  }\n  function norm2(a) {\n    return Math.sqrt(dot(a, a));\n  }\n  function scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n      ret[i] = value[i] * c;\n    }\n  }\n  function weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n      ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n  }\n\n  /** minimizes a function using the downhill simplex method */\n  function nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n      nonZeroDelta = parameters.nonZeroDelta || 1.05,\n      zeroDelta = parameters.zeroDelta || 0.001,\n      minErrorDelta = parameters.minErrorDelta || 1e-6,\n      minTolerance = parameters.minErrorDelta || 1e-5,\n      rho = parameters.rho !== undefined ? parameters.rho : 1,\n      chi = parameters.chi !== undefined ? parameters.chi : 2,\n      psi = parameters.psi !== undefined ? parameters.psi : -0.5,\n      sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5,\n      maxDiff;\n\n    // initialize simplex.\n    var N = x0.length,\n      simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (var i = 0; i < N; ++i) {\n      var point = x0.slice();\n      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n      simplex[i + 1] = point;\n      simplex[i + 1].fx = f(point);\n      simplex[i + 1].id = i + 1;\n    }\n    function updateSimplex(value) {\n      for (var i = 0; i < value.length; i++) {\n        simplex[N][i] = value[i];\n      }\n      simplex[N].fx = value.fx;\n    }\n    var sortOrder = function (a, b) {\n      return a.fx - b.fx;\n    };\n    var centroid = x0.slice(),\n      reflected = x0.slice(),\n      contracted = x0.slice(),\n      expanded = x0.slice();\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n      simplex.sort(sortOrder);\n      if (parameters.history) {\n        // copy the simplex (since later iterations will mutate) and\n        // sort it to have a consistent order between iterations\n        var sortedSimplex = simplex.map(function (x) {\n          var state = x.slice();\n          state.fx = x.fx;\n          state.id = x.id;\n          return state;\n        });\n        sortedSimplex.sort(function (a, b) {\n          return a.id - b.id;\n        });\n        parameters.history.push({\n          x: simplex[0].slice(),\n          fx: simplex[0].fx,\n          simplex: sortedSimplex\n        });\n      }\n      maxDiff = 0;\n      for (i = 0; i < N; ++i) {\n        maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n      }\n      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n        break;\n      }\n\n      // compute the centroid of all but the worst point in the simplex\n      for (i = 0; i < N; ++i) {\n        centroid[i] = 0;\n        for (var j = 0; j < N; ++j) {\n          centroid[i] += simplex[j][i];\n        }\n        centroid[i] /= N;\n      }\n\n      // reflect the worst point past the centroid  and compute loss at reflected\n      // point\n      var worst = simplex[N];\n      weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n      reflected.fx = f(reflected);\n\n      // if the reflected point is the best seen, then possibly expand\n      if (reflected.fx < simplex[0].fx) {\n        weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n        expanded.fx = f(expanded);\n        if (expanded.fx < reflected.fx) {\n          updateSimplex(expanded);\n        } else {\n          updateSimplex(reflected);\n        }\n      }\n\n      // if the reflected point is worse than the second worst, we need to\n      // contract\n      else if (reflected.fx >= simplex[N - 1].fx) {\n        var shouldReduce = false;\n        if (reflected.fx > worst.fx) {\n          // do an inside contraction\n          weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n          contracted.fx = f(contracted);\n          if (contracted.fx < worst.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        } else {\n          // do an outside contraction\n          weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n          contracted.fx = f(contracted);\n          if (contracted.fx < reflected.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        }\n        if (shouldReduce) {\n          // if we don't contract here, we're done\n          if (sigma >= 1) break;\n\n          // do a reduction\n          for (i = 1; i < simplex.length; ++i) {\n            weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n            simplex[i].fx = f(simplex[i]);\n          }\n        }\n      } else {\n        updateSimplex(reflected);\n      }\n    }\n    simplex.sort(sortOrder);\n    return {\n      fx: simplex[0].fx,\n      x: simplex[0]\n    };\n  }\n\n  /// searches along line 'pk' for a point that satifies the wolfe conditions\n  /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n  /// f : objective function\n  /// pk : search direction\n  /// current: object containing current gradient/loss\n  /// next: output: contains next gradient/loss\n  /// returns a: step size taken\n  function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx,\n      phiPrime0 = dot(current.fxprime, pk),\n      phi = phi0,\n      phi_old = phi0,\n      phiPrime = phiPrime0,\n      a0 = 0;\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n    function zoom(a_lo, a_high, phi_lo) {\n      for (var iteration = 0; iteration < 16; ++iteration) {\n        a = (a_lo + a_high) / 2;\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n        if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n          a_high = a;\n        } else {\n          if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n          }\n          if (phiPrime * (a_high - a_lo) >= 0) {\n            a_high = a_lo;\n          }\n          a_lo = a;\n          phi_lo = phi;\n        }\n      }\n      return 0;\n    }\n    for (var iteration = 0; iteration < 10; ++iteration) {\n      weightedSum(next.x, 1.0, current.x, a, pk);\n      phi = next.fx = f(next.x, next.fxprime);\n      phiPrime = dot(next.fxprime, pk);\n      if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {\n        return zoom(a0, a, phi_old);\n      }\n      if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n        return a;\n      }\n      if (phiPrime >= 0) {\n        return zoom(a, a0, phi);\n      }\n      phi_old = phi;\n      a0 = a;\n      a *= 2;\n    }\n    return a;\n  }\n  function conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      next = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      yk = initial.slice(),\n      pk,\n      temp,\n      a = 1,\n      maxIterations;\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime, -1);\n    for (var i = 0; i < maxIterations; ++i) {\n      a = wolfeLineSearch(f, pk, current, next, a);\n\n      // todo: history in wrong spot?\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          alpha: a\n        });\n      }\n      if (!a) {\n        // faiiled to find point that satifies wolfe conditions.\n        // reset direction for next iteration\n        scale(pk, current.fxprime, -1);\n      } else {\n        // update direction using Polak–Ribiere CG method\n        weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n        var delta_k = dot(current.fxprime, current.fxprime),\n          beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n        weightedSum(pk, beta_k, pk, -1, next.fxprime);\n        temp = current;\n        current = next;\n        next = temp;\n      }\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        alpha: a\n      });\n    }\n    return current;\n  }\n  function gradientDescent(f, initial, params) {\n    params = params || {};\n    var maxIterations = params.maxIterations || initial.length * 100,\n      learnRate = params.learnRate || 0.001,\n      current = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      };\n    for (var i = 0; i < maxIterations; ++i) {\n      current.fx = f(current.x, current.fxprime);\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice()\n        });\n      }\n      weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n    return current;\n  }\n  function gradientDescentLineSearch(f, initial, params) {\n    params = params || {};\n    var current = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      next = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      maxIterations = params.maxIterations || initial.length * 100,\n      learnRate = params.learnRate || 1,\n      pk = initial.slice(),\n      c1 = params.c1 || 1e-3,\n      c2 = params.c2 || 0.1,\n      temp,\n      functionCalls = [];\n    if (params.history) {\n      // wrap the function call to track linesearch samples\n      var inner = f;\n      f = function (x, fxprime) {\n        functionCalls.push(x.slice());\n        return inner(x, fxprime);\n      };\n    }\n    current.fx = f(current.x, current.fxprime);\n    for (var i = 0; i < maxIterations; ++i) {\n      scale(pk, current.fxprime, -1);\n      learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          functionCalls: functionCalls,\n          learnRate: learnRate,\n          alpha: learnRate\n        });\n        functionCalls = [];\n      }\n      temp = current;\n      current = next;\n      next = temp;\n      if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;\n    }\n    return current;\n  }\n  exports.bisect = bisect;\n  exports.nelderMead = nelderMead;\n  exports.conjugateGradient = conjugateGradient;\n  exports.gradientDescent = gradientDescent;\n  exports.gradientDescentLineSearch = gradientDescentLineSearch;\n  exports.zeros = zeros;\n  exports.zerosM = zerosM;\n  exports.norm2 = norm2;\n  exports.weightedSum = weightedSum;\n  exports.scale = scale;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","fmin","bisect","f","a","b","parameters","maxIterations","tolerance","fA","fB","delta","i","mid","fMid","Math","abs","zeros","x","r","Array","zerosM","y","map","dot","ret","length","norm2","sqrt","scale","value","c","weightedSum","w1","v1","w2","v2","j","nelderMead","x0","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","maxDiff","N","simplex","fx","id","point","slice","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","sort","history","sortedSimplex","state","push","max","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","yk","temp","alpha","delta_k","beta_k","gradientDescent","learnRate","gradientDescentLineSearch","functionCalls","inner"],"sources":["/Users/turalmammadov/Downloads/MERN/admin-app/node_modules/fmin/build/fmin.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.fmin = global.fmin || {})));\n}(this, function (exports) { 'use strict';\n\n    /** finds the zeros of a function, given two starting points (which must\n     * have opposite signs */\n    function bisect(f, a, b, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || 100,\n            tolerance = parameters.tolerance || 1e-10,\n            fA = f(a),\n            fB = f(b),\n            delta = b - a;\n\n        if (fA * fB > 0) {\n            throw \"Initial bisect points must have opposite signs\";\n        }\n\n        if (fA === 0) return a;\n        if (fB === 0) return b;\n\n        for (var i = 0; i < maxIterations; ++i) {\n            delta /= 2;\n            var mid = a + delta,\n                fMid = f(mid);\n\n            if (fMid * fA >= 0) {\n                a = mid;\n            }\n\n            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n                return mid;\n            }\n        }\n        return a + delta;\n    }\n\n    // need some basic operations on vectors, rather than adding a dependency,\n    // just define here\n    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\n    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\n    function dot(a, b) {\n        var ret = 0;\n        for (var i = 0; i < a.length; ++i) {\n            ret += a[i] * b[i];\n        }\n        return ret;\n    }\n\n    function norm2(a)  {\n        return Math.sqrt(dot(a, a));\n    }\n\n    function scale(ret, value, c) {\n        for (var i = 0; i < value.length; ++i) {\n            ret[i] = value[i] * c;\n        }\n    }\n\n    function weightedSum(ret, w1, v1, w2, v2) {\n        for (var j = 0; j < ret.length; ++j) {\n            ret[j] = w1 * v1[j] + w2 * v2[j];\n        }\n    }\n\n    /** minimizes a function using the downhill simplex method */\n    function nelderMead(f, x0, parameters) {\n        parameters = parameters || {};\n\n        var maxIterations = parameters.maxIterations || x0.length * 200,\n            nonZeroDelta = parameters.nonZeroDelta || 1.05,\n            zeroDelta = parameters.zeroDelta || 0.001,\n            minErrorDelta = parameters.minErrorDelta || 1e-6,\n            minTolerance = parameters.minErrorDelta || 1e-5,\n            rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n            chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n            maxDiff;\n\n        // initialize simplex.\n        var N = x0.length,\n            simplex = new Array(N + 1);\n        simplex[0] = x0;\n        simplex[0].fx = f(x0);\n        simplex[0].id = 0;\n        for (var i = 0; i < N; ++i) {\n            var point = x0.slice();\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n            simplex[i+1] = point;\n            simplex[i+1].fx = f(point);\n            simplex[i+1].id = i+1;\n        }\n\n        function updateSimplex(value) {\n            for (var i = 0; i < value.length; i++) {\n                simplex[N][i] = value[i];\n            }\n            simplex[N].fx = value.fx;\n        }\n\n        var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n        var centroid = x0.slice(),\n            reflected = x0.slice(),\n            contracted = x0.slice(),\n            expanded = x0.slice();\n\n        for (var iteration = 0; iteration < maxIterations; ++iteration) {\n            simplex.sort(sortOrder);\n\n            if (parameters.history) {\n                // copy the simplex (since later iterations will mutate) and\n                // sort it to have a consistent order between iterations\n                var sortedSimplex = simplex.map(function (x) {\n                    var state = x.slice();\n                    state.fx = x.fx;\n                    state.id = x.id;\n                    return state;\n                });\n                sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n                parameters.history.push({x: simplex[0].slice(),\n                                         fx: simplex[0].fx,\n                                         simplex: sortedSimplex});\n            }\n\n            maxDiff = 0;\n            for (i = 0; i < N; ++i) {\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n            }\n\n            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n                (maxDiff < minTolerance)) {\n                break;\n            }\n\n            // compute the centroid of all but the worst point in the simplex\n            for (i = 0; i < N; ++i) {\n                centroid[i] = 0;\n                for (var j = 0; j < N; ++j) {\n                    centroid[i] += simplex[j][i];\n                }\n                centroid[i] /= N;\n            }\n\n            // reflect the worst point past the centroid  and compute loss at reflected\n            // point\n            var worst = simplex[N];\n            weightedSum(reflected, 1+rho, centroid, -rho, worst);\n            reflected.fx = f(reflected);\n\n            // if the reflected point is the best seen, then possibly expand\n            if (reflected.fx < simplex[0].fx) {\n                weightedSum(expanded, 1+chi, centroid, -chi, worst);\n                expanded.fx = f(expanded);\n                if (expanded.fx < reflected.fx) {\n                    updateSimplex(expanded);\n                }  else {\n                    updateSimplex(reflected);\n                }\n            }\n\n            // if the reflected point is worse than the second worst, we need to\n            // contract\n            else if (reflected.fx >= simplex[N-1].fx) {\n                var shouldReduce = false;\n\n                if (reflected.fx > worst.fx) {\n                    // do an inside contraction\n                    weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < worst.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                } else {\n                    // do an outside contraction\n                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < reflected.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                }\n\n                if (shouldReduce) {\n                    // if we don't contract here, we're done\n                    if (sigma >= 1) break;\n\n                    // do a reduction\n                    for (i = 1; i < simplex.length; ++i) {\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                        simplex[i].fx = f(simplex[i]);\n                    }\n                }\n            } else {\n                updateSimplex(reflected);\n            }\n        }\n\n        simplex.sort(sortOrder);\n        return {fx : simplex[0].fx,\n                x : simplex[0]};\n    }\n\n    /// searches along line 'pk' for a point that satifies the wolfe conditions\n    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n    /// f : objective function\n    /// pk : search direction\n    /// current: object containing current gradient/loss\n    /// next: output: contains next gradient/loss\n    /// returns a: step size taken\n    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n            phi = phi0, phi_old = phi0,\n            phiPrime = phiPrime0,\n            a0 = 0;\n\n        a = a || 1;\n        c1 = c1 || 1e-6;\n        c2 = c2 || 0.1;\n\n        function zoom(a_lo, a_high, phi_lo) {\n            for (var iteration = 0; iteration < 16; ++iteration) {\n                a = (a_lo + a_high)/2;\n                weightedSum(next.x, 1.0, current.x, a, pk);\n                phi = next.fx = f(next.x, next.fxprime);\n                phiPrime = dot(next.fxprime, pk);\n\n                if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                    (phi >= phi_lo)) {\n                    a_high = a;\n\n                } else  {\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                        return a;\n                    }\n\n                    if (phiPrime * (a_high - a_lo) >=0) {\n                        a_high = a_lo;\n                    }\n\n                    a_lo = a;\n                    phi_lo = phi;\n                }\n            }\n\n            return 0;\n        }\n\n        for (var iteration = 0; iteration < 10; ++iteration) {\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (iteration && (phi >= phi_old))) {\n                return zoom(a0, a, phi_old);\n            }\n\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                return a;\n            }\n\n            if (phiPrime >= 0 ) {\n                return zoom(a, a0, phi);\n            }\n\n            phi_old = phi;\n            a0 = a;\n            a *= 2;\n        }\n\n        return a;\n    }\n\n    function conjugateGradient(f, initial, params) {\n        // allocate all memory up front here, keep out of the loop for perfomance\n        // reasons\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            yk = initial.slice(),\n            pk, temp,\n            a = 1,\n            maxIterations;\n\n        params = params || {};\n        maxIterations = params.maxIterations || initial.length * 20;\n\n        current.fx = f(current.x, current.fxprime);\n        pk = current.fxprime.slice();\n        scale(pk, current.fxprime,-1);\n\n        for (var i = 0; i < maxIterations; ++i) {\n            a = wolfeLineSearch(f, pk, current, next, a);\n\n            // todo: history in wrong spot?\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     alpha: a});\n            }\n\n            if (!a) {\n                // faiiled to find point that satifies wolfe conditions.\n                // reset direction for next iteration\n                scale(pk, current.fxprime, -1);\n\n            } else {\n                // update direction using Polak–Ribiere CG method\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n                var delta_k = dot(current.fxprime, current.fxprime),\n                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n                temp = current;\n                current = next;\n                next = temp;\n            }\n\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        return current;\n    }\n\n    function gradientDescent(f, initial, params) {\n        params = params || {};\n        var maxIterations = params.maxIterations || initial.length * 100,\n            learnRate = params.learnRate || 0.001,\n            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};\n\n        for (var i = 0; i < maxIterations; ++i) {\n            current.fx = f(current.x, current.fxprime);\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice()});\n            }\n\n            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        return current;\n    }\n\n    function gradientDescentLineSearch(f, initial, params) {\n        params = params || {};\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            maxIterations = params.maxIterations || initial.length * 100,\n            learnRate = params.learnRate || 1,\n            pk = initial.slice(),\n            c1 = params.c1 || 1e-3,\n            c2 = params.c2 || 0.1,\n            temp,\n            functionCalls = [];\n\n        if (params.history) {\n            // wrap the function call to track linesearch samples\n            var inner = f;\n            f = function(x, fxprime) {\n                functionCalls.push(x.slice());\n                return inner(x, fxprime);\n            };\n        }\n\n        current.fx = f(current.x, current.fxprime);\n        for (var i = 0; i < maxIterations; ++i) {\n            scale(pk, current.fxprime, -1);\n            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     functionCalls: functionCalls,\n                                     learnRate: learnRate,\n                                     alpha: learnRate});\n                functionCalls = [];\n            }\n\n\n            temp = current;\n            current = next;\n            next = temp;\n\n            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;\n        }\n\n        return current;\n    }\n\n    exports.bisect = bisect;\n    exports.nelderMead = nelderMead;\n    exports.conjugateGradient = conjugateGradient;\n    exports.gradientDescent = gradientDescent;\n    exports.gradientDescentLineSearch = gradientDescentLineSearch;\n    exports.zeros = zeros;\n    exports.zerosM = zerosM;\n    exports.norm2 = norm2;\n    exports.weightedSum = weightedSum;\n    exports.scale = scale;\n\n}));"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}